<?php
/*
 * Your installation or use of this DotBCRM file is subject to the applicable
 * terms available at
 * http://support.dotbcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this DotBCRM file.
 *
 * Copyright (C) DotBCRM Inc. All rights reserved.
 */

namespace Dotbcrm\Stage2;

require_once('include/upload_file.php');
require_once('include/utils/encryption_utils.php');
require_once('include/DotbSystemInfo/DotbSystemInfo.php');
require_once('Stage2HttpClient.php');

use DotbApiException;
use DotbApiExceptionNotAuthorized;

/**
 * Class Stage2Manager - this is singleton used to access all Stage2 service.
 *
 * @package Dotbcrm\Stage2\Stage2Manager
 */
class Stage2Manager
{
    //
    //  Class constants
    //
    /**
     * @var string Configuration key for endpoint.
     */
    const CONFIG_KEY_SERVICE_URL = 'service-url';
    /**
     * @var string Configuration key for Stage2 obfuscation salt. This salt value is used whenever
     * there is a need to uniquelly (accross all DotBCRM client instances) obfuscate a datum
     * (e.g. user's analytic's ID) It is both random and unknown to Stage2 service to prevent
     * reversing obfuscation.
     */
    const CONFIG_KEY_OBFUSCATION_SALT = 'obfuscation-salt';
    /**
     * @var string IS module name.
     */
    const MODULE = 'Stage2';
    /**
     * @var string IS platform.
     */
    const PLATFORM = 'base';
    /**
     * @var string Key for access token in Stage2 authentication response.
     */
    const KEY_ACCESS_TOKEN = 'token';

    /**
     * @var string Key for subscription type in Stage2 authentication response.
     */
    const SUBSCRIPTION_TYPE = 'subscriptionType';

    /**
     * Get instance.
     */
    public static function instance()
    {
        //  Singleton instance.
        static $instance = null;

        if (is_null($instance)) {
            $instance = new Stage2Manager();
        }
        $instance->initialize();

        return $instance;
    }

    public $serviceUrl = null;
    public $instanceId = null;
    public $licenseKey = null;
    public $dotbVersion = null;

    /**
     * Initialize internal variables.
     */
    public function initialize()
    {
        $GLOBALS['log']->info('Initializing shared instance of Stage2Manager.');

        //  Load configuration from the database.
        $dbConfig = $this->loadConfig();

        //  Salt is not included in the optional client config file as it has to be both unique
        //  accross all DotBCRM client instances *and* remain unknown to our service (otherwise
        //  obfuscation could be reversed). Thus the salt is always generated by the DotBCRM
        //  instance itself.
        //  Always initialize the salt as it may be even used without the rest of the config.
        if (array_key_exists(static::CONFIG_KEY_OBFUSCATION_SALT, $dbConfig)) {
            $this->obfuscationSalt = $dbConfig[static::CONFIG_KEY_OBFUSCATION_SALT];
        } else {
            $this->obfuscationSalt = uniqid();
            \BeanFactory::getBean('Administration')->saveSetting(
                static::MODULE,
                static::CONFIG_KEY_OBFUSCATION_SALT,
                $this->obfuscationSalt,
                static::PLATFORM);
        }

        //  Also try to load optional client config file which may be included with
        //  some distributions. When it is, the configuration from the database
        //  still takes precedence.
        $buildConfig = include 'Stage2ClientBuildConfig.php';

        //  Read client options and create the client.
        $serviceUrl = static::readOptionFromConfigurations(
            $dbConfig, $buildConfig, static::CONFIG_KEY_SERVICE_URL);
        if (is_null($serviceUrl) || empty($serviceUrl)) {
            $GLOBALS['log']->error('Missing ' . static::CONFIG_KEY_SERVICE_URL . ' Stage2 config param.');
            return;
        } else {
            $this->serviceUrl = $serviceUrl;
        }

        // Read instance ID and license key from system info.
        $systemInfo = \DotbSystemInfo::getInstance();
        $this->instanceId = $systemInfo->getApplicationKeyInfo()['application_key'];
        $this->licenseKey = $systemInfo->getLicenseKey();
        $this->dotbVersion = $systemInfo->getAppInfo()['dotb_version'];

        $GLOBALS['log']->info('Shared instance of Stage2Manager initialized.');
    }

    /**
     * Get a new access token.
     *
     * @return array (string indexed)
     * @throws DotbApiException
     * @throws DotbApiExceptionError
     * @throws DotbApiExceptionInvalidGrant
     * @throws DotbApiExceptionNotAuthorized
     * @throws DotbApiExceptionNotFound
     */
    public function getNewAccessToken()
    {
        if (is_null($this->instanceId) ||
            is_null($this->licenseKey)
        ) {
            $GLOBALS['log']->error('Missing Stage2 client ID/secret');
            throw new DotbApiExceptionNotAuthorized('Bad configuration for Stage2');
        }

        $stage2client = new Stage2HttpClient($this->serviceUrl);
        $stage2client->instanceId = $this->instanceId;
        $stage2client->licenseKey = $this->licenseKey;

        //  Obtain access token for Stage2.
        $response = $stage2client->newToken();
        if (!is_array($response) ||
            !array_key_exists(static::KEY_ACCESS_TOKEN, $response)
        ) {
            throw new DotbApiException('Bad response from Stage2 authorize');
        }

        $tokenResponse = array('accessToken' => $response[static::KEY_ACCESS_TOKEN]);
        // older servers won't send the subscription type, so be check before using
        if (isset($response[static::SUBSCRIPTION_TYPE])) {
            $tokenResponse['subscriptionType'] = $response[static::SUBSCRIPTION_TYPE];
        }
        return $tokenResponse;
    }

    /**
     * Return persisted configuration options for the given key.
     * If there are none, empty array is returned.
     *
     * @return array Options loaded from the configuration.
     */
    public static function loadConfig()
    {
        return \BeanFactory::getBean('Administration')->getConfigForModule(
            static::MODULE,
            static::PLATFORM,
            true/*Always get clean copy to avoid dirty reads*/);
    }

    public function getCurrentUserAnalyticsId()
    {
        return sha1($this->obfuscationSalt . $GLOBALS['current_user']->id);
    }

    public function getISPs()
    {
        $uploadFile = new \UploadFile();
        $uploadFile->temp_file_location = 'custom/Stage2/isp-list.json';
        $content = $uploadFile->get_file_contents();
        return $content;
    }

    private static function readOptionFromConfigurations($dbConfig, $buildConfig, $option)
    {
        //  Database configuration takes precedence over build client configuration
        //  as we will never instruct administrators to change their local files but
        //  rather configuration in the database.
        if (array_key_exists($option, $dbConfig)) {
            return $dbConfig[$option];
        } else if (!is_null($buildConfig) && array_key_exists($option, $buildConfig)) {
            return $buildConfig[$option];
        } else {
            return null;
        }
    }

    /**
     * Filter the Hint fields which should NOT be included in the record metadata. Hint configuration
     * is stored in the configuration module specific to the module in question.
     *
     * @param $adminBean
     * @param $module
     * @param $hint_panel
     */
    public static function filterHintRecordFieldsMetadata($adminBean, $module, $hint_panel)
    {
        $moduleconfig = $adminBean->getConfigForModule($module);


        if(isset($moduleconfig['hintConfig'])) {

            $newFieldsArray = array();

            $allFieldsThatWillBeDisplayed = array_merge($moduleconfig['hintConfig']['basic'],$moduleconfig['hintConfig']['expanded']);

            $isAccountsModule = $module === 'Accounts';
            if(!$isAccountsModule) {
                $accountsModuleconfig = $adminBean->getConfigForModule("Accounts");
                $allAccountsFieldsThatWillBeDisplayed = array_merge($accountsModuleconfig['hintConfig']['basic'],$accountsModuleconfig['hintConfig']['expanded']);
            }


            foreach($hint_panel['fields'] as $field) {

                $key = is_array($field) ? $field['name'] : $field;
                $whiteList = (is_array($field) && array_key_exists( 'white_list', $field)) ? $field['white_list'] : false;
                $accountKey = (is_array($field) && array_key_exists( 'account_key', $field)) ? $field['account_key'] : false;
                $parentKey = (is_array($field) && array_key_exists( 'parent_key', $field)) ? $field['parent_key'] : false;

                $isFieldConfiguredToBeShown = in_array($key, $allFieldsThatWillBeDisplayed);
                $isParentKeyConfiguredToBeShown = $parentKey && in_array($parentKey, $allFieldsThatWillBeDisplayed);

                //When we're processing modules other than accounts (eg. contacts, leads) we may need to look at fields that are in the accounts metadata since those views are 'composed' of accounts info.  The
                //$isAccountsModule flag adds this restriction so that this logic is not considered when processing the accounts module itself.
                $isFieldInAccountsModuleAndConfiguredToBeShown = !$isAccountsModule && ( in_array($key, $allAccountsFieldsThatWillBeDisplayed) || ($accountKey && in_array($accountKey, $allAccountsFieldsThatWillBeDisplayed)));

                if($whiteList || $isFieldConfiguredToBeShown || $isParentKeyConfiguredToBeShown || $isFieldInAccountsModuleAndConfiguredToBeShown) {

                    $newFieldsArray[] = $field;
                }
            }

            return $newFieldsArray;
        }
        else {
            return $hint_panel['fields'];
        }
    }
}
